<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        #maze {
            display: flex;
            flex-wrap: wrap;
            width: 102px; /* Adjusted to fit 10 cells of 10px with gaps */
            margin-bottom: 20px;
        }
        .cell {
            width: 10px;
            height: 10px;
            background-color: #ddd;
            border: 1px solid #bbb;
            box-sizing: border-box;
        }
        .start {
            background-color: #4CAF50;
        }
        .target {
            background-color: #FF5733;
        }
        .obstacle {
            background-color: #000;
        }
        .path {
            background-color: #00BCD4; /* Color for the path */
        }
    </style>
</head>
<body>
    <h2>Maze Solver AI</h2>
    <div id="maze"></div>
    <button id="startBtn">Start</button>
    <button id="resetBtn">Reset</button>

    <script>
        var rows = 10, cols = 10;
        var startNode = { x: 0, y: 0 }, targetNode = { x: 9, y: 9 };
        var maze = document.getElementById('maze');
        var openList = [], closedList = [];

        // Generate maze grid
        function generateGrid() {
            maze.innerHTML = ''; // Clear existing maze
            for (var y = 0; y < rows; y++) {
                for (var x = 0; x < cols; x++) {
                    var cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.onclick = toggleCell; // Assign click handler
                    maze.appendChild(cell);
                }
            }
            setCell(startNode.x, startNode.y, 'start');
            setCell(targetNode.x, targetNode.y, 'target');
        }

        function setCell(x, y, type) {
            var cell = maze.querySelector(`[data-x='${x}'][data-y='${y}']`);
            if (cell) {
                cell.className = 'cell'; // Reset to base class
                cell.classList.add(type);
            }
        }

        function toggleCell(event) {
            var cell = event.target;
            var x = parseInt(cell.dataset.x);
            var y = parseInt(cell.dataset.y);

            // Prevent toggling start or target cells
            if ((x === startNode.x && y === startNode.y) || (x === targetNode.x && y === targetNode.y)) return;

            cell.classList.toggle('obstacle'); // Toggle obstacle class
        }

        function startMaze() {
            aStar(); // Start the A* algorithm
        }

        function aStar() {
            openList = [{ ...startNode, g: 0, f: heuristic(startNode, targetNode), parent: null }];
            closedList = [];

            while (openList.length > 0) {
                // Sort open list by f value and pick the node with the lowest f
                openList.sort((a, b) => a.f - b.f);
                const current = openList.shift(); // Get the node with the lowest f

                closedList.push(current); // Add current node to closed list

                // If we reached the target, end
                if (current.x === targetNode.x && current.y === targetNode.y) {
                    drawPath(current);
                    return;
                }

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (!closedList.find(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        // Check if it's already in openList
                        const existingNode = openList.find(node => node.x === neighbor.x && node.y === neighbor.y);
                        const newG = current.g + 1;

                        if (!existingNode || newG < neighbor.g) {
                            neighbor.g = newG;
                            neighbor.f = neighbor.g + heuristic(neighbor, targetNode);
                            neighbor.parent = current; // Set current as parent
                            if (!existingNode) {
                                openList.push(neighbor); // Add neighbor to open list if not present
                            }
                        }
                    }
                }
            }
        }

        function heuristic(node, target) {
            return Math.abs(node.x - target.x) + Math.abs(node.y - target.y);
        }

        function getNeighbors(node) {
            const directions = [
                { x: 0, y: -1 }, { x: 1, y: 0 },
                { x: 0, y: 1 }, { x: -1, y: 0 }
            ];
            const neighbors = [];

            for (const dir of directions) {
                const x = node.x + dir.x;
                const y = node.y + dir.y;
                const cell = maze.querySelector(`[data-x='${x}'][data-y='${y}']`);
                if (x >= 0 && x < cols && y >= 0 && y < rows && cell && !cell.classList.contains('obstacle')) {
                    neighbors.push({ x, y, g: Infinity, f: Infinity, parent: null });
                }
            }
            return neighbors;
        }

        function drawPath(current) {
            while (current) {
                if (!(current.x === startNode.x && current.y === startNode.y) && !(current.x === targetNode.x && current.y === targetNode.y)) {
                    setCell(current.x, current.y, 'path');
                }
                current = current.parent; // Move to the parent
            }
        }

        function resetMaze() {
            generateGrid(); // Regenerate grid
            openList = [];
            closedList = [];
        }

        // Initialize maze
        generateGrid();

        // Attach event listeners to buttons
        document.getElementById('startBtn').addEventListener('click', startMaze);
        document.getElementById('resetBtn').addEventListener('click', resetMaze);
    </script>
</body>
</html>
