<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px; /* Add some padding */
            background-color: #f5f5f5; /* Light background for better visibility */
        }
        #maze {
            display: flex;
            flex-wrap: wrap; /* Allow cells to wrap onto new lines */
            width: 204px; /* Set width to fit 10 cells of 10px with gaps */
            margin-bottom: 20px; /* Space between maze and buttons */
        }
        .cell {
            width: 20px;
            height: 20px;
            background-color: #ddd;
            border: 1px solid #bbb;
            box-sizing: border-box; /* Include border in width and height */
        }
        .start {
            background-color: #4CAF50;
        }
        .target {
            background-color: #FF5733;
        }
        .obstacle {
            background-color: #000;
        }
        .path {
            background-color: #00BCD4; /* Color for the path found */
        }
    </style>
</head>
<body>
    <h2>Maze Solver AI</h2>
    <div id="maze"></div>
    <button onclick="startMaze()">Start</button>
    <button onclick="resetMaze()">Reset</button>

    <script>
        var rows = 10, cols = 10;
        var startNode = { x: 0, y: 0 }, targetNode = { x: 9, y: 9 };
        var maze = document.getElementById('maze');

        
        // Initialize maze
        generateGrid();
        // Generate maze grid
        function generateGrid() {
            maze.innerHTML = ''; // Clear existing maze
            for (var y = 0; y < rows; y++) {
                for (var x = 0; x < cols; x++) {
                    var cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.onclick = toggleCell; // Assign click handler
                    maze.appendChild(cell);
                }
            }
            setCell(startNode.x, startNode.y, 'start');
            setCell(targetNode.x, targetNode.y, 'target');
        }

        function setCell(x, y, type) {
            var cell = maze.querySelector(`[data-x='${x}'][data-y='${y}']`);
            if (cell) {
                cell.className = 'cell'; // Reset to base class
                cell.classList.add(type);
            }
        }

        function toggleCell(event) {
            var cell = event.target;
            var x = parseInt(cell.dataset.x);
            var y = parseInt(cell.dataset.y);

            // Prevent toggling start or target cells
            if ((x === startNode.x && y === startNode.y) || (x === targetNode.x && y === targetNode.y)) return;

            cell.classList.toggle('obstacle'); // Toggle obstacle class
        }

        function heuristic(node, target) {
            // Use Manhattan distance as the heuristic
            return Math.abs(node.x - target.x) + Math.abs(node.y - target.y);
        }

        // function getNeighbors(node) {
        //     const directions = [
        //         { x: 0, y: -1 }, { x: 1, y: 0 },
        //         { x: 0, y: 1 }, { x: -1, y: 0 }
        //     ];
        //     const neighbors = [];

        //     for (const dir of directions) {
        //         const x = node.x + dir.x;
        //         const y = node.y + dir.y;
        //         const cell = maze.querySelector(`[data-x='${x}'][data-y='${y}']`);
        //         if (x >= 0 && x < cols && y >= 0 && y < rows && cell && !cell.classList.contains('obstacle')) {
        //             neighbors.push({ x, y });
        //         }
        //     }
        //     return neighbors;
        // }

        function reconstructPath(current) {
            while (current) {
                setCell(current.x, current.y, 'path');
                current = current.parent;
            }
        }

        function aStar() {
            let openList = [{ ...startNode, g: 0, f: heuristic(startNode, targetNode), parent: null }];
            let closedList = [];

            while (openList.length > 0) {
                // Sort open list to find the node with the lowest f score
                openList.sort((a, b) => a.f - b.f);
                const current = openList.shift(); // Get node with the lowest f score

                // If we reached the target, end
                if (current.x === targetNode.x && current.y === targetNode.y) {
                    reconstructPath(current);
                    return;
                }

                closedList.push(current);

                // Get neighbors and calculate scores
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    // Ignore already evaluated neighbors
                    if (closedList.find(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        continue; 
                    }

                    const gScore = current.g + 1; // Cost from start to neighbor
                    const gScoreIsBest = !openList.find(node => node.x === neighbor.x && node.y === neighbor.y) || (gScore < neighbor.g);
                    if (gScoreIsBest) {
                        neighbor.g = gScore;
                        neighbor.f = neighbor.g + heuristic(neighbor, targetNode);
                        neighbor.parent = current; // Track the parent node

                        // Add neighbor to open list if not already present
                        if (!openList.find(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openList.push(neighbor);
                        }
                    }
                }
            }
            alert("No path found!"); // Alert if no path is found
        }

        function startMaze() {
            aStar(); // Start the pathfinding process
        }

        function resetMaze() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('path'); // Remove path class
            });
            setCell(startNode.x, startNode.y, 'start');
            setCell(targetNode.x, targetNode.y, 'target');
        }
    </script>
</body>
</html>
